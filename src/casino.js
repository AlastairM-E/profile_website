import React, { useState, } from 'react';

/* Deck - an array, whcih contains objects, adn each of those objects are cards. */
const standardDeck = {
    cardsTakenFromLibrary : [],
    library : shuffle([
        {"rank" : 1, "cardSuit" : "hearts"},
        {"rank" : 2, "cardSuit" : "hearts"},
        {"rank" : 3, "cardSuit" : "hearts"},
        {"rank" : 4, "cardSuit" : "hearts"},
        {"rank" : 5, "cardSuit" : "hearts"},
        {"rank" : 6, "cardSuit" : "hearts"},
        {"rank" : 7, "cardSuit" : "hearts"},
        {"rank" : 8, "cardSuit" : "hearts"},
        {"rank" : 9, "cardSuit" : "hearts"},
        {"rank" : 10, "cardSuit" : "hearts"},
        {"rank" : 11, "cardSuit" : "hearts"},
        {"rank" : 12, "cardSuit" : "hearts"},
        {"rank" : 13, "cardSuit" : "hearts"},
        {"rank" : 14, "cardSuit" : "hearts"},

        {"rank" : 1, "cardSuit" : "diamonds"},
        {"rank" : 2, "cardSuit" : "diamonds"},
        {"rank" : 3, "cardSuit" : "diamonds"},
        {"rank" : 4, "cardSuit" : "diamonds"},
        {"rank" : 5, "cardSuit" : "diamonds"},
        {"rank" : 6, "cardSuit" : "diamonds"},
        {"rank" : 7, "cardSuit" : "diamonds"},
        {"rank" : 8, "cardSuit" : "diamonds"},
        {"rank" : 9, "cardSuit" : "diamonds"},
        {"rank" : 10, "cardSuit" : "diamonds"},
        {"rank" : 11, "cardSuit" : "diamonds"},
        {"rank" : 12, "cardSuit" : "diamonds"},
        {"rank" : 13, "cardSuit" : "diamonds"},
        {"rank" : 14, "cardSuit" : "diamonds"},

        {"rank" : 1, "cardSuit" : "clubs"},
        {"rank" : 2, "cardSuit" : "clubs"},
        {"rank" : 3, "cardSuit" : "clubs"},
        {"rank" : 4, "cardSuit" : "clubs"},
        {"rank" : 5, "cardSuit" : "clubs"},
        {"rank" : 6, "cardSuit" : "clubs"},
        {"rank" : 7, "cardSuit" : "clubs"},
        {"rank" : 8, "cardSuit" : "clubs"},
        {"rank" : 9, "cardSuit" : "clubs"},
        {"rank" : 10, "cardSuit" : "clubs"},
        {"rank" : 11, "cardSuit" : "clubs"},
        {"rank" : 12, "cardSuit" : "clubs"},
        {"rank" : 13, "cardSuit" : "clubs"},
        {"rank" : 14, "cardSuit" : "clubs"},

        {"rank" : 1, "cardSuit" : "spades"},
        {"rank" : 2, "cardSuit" : "spades"},
        {"rank" : 3, "cardSuit" : "spades"},
        {"rank" : 4, "cardSuit" : "spades"},
        {"rank" : 5, "cardSuit" : "spades"},
        {"rank" : 6, "cardSuit" : "spades"},
        {"rank" : 7, "cardSuit" : "spades"},
        {"rank" : 8, "cardSuit" : "spades"},
        {"rank" : 9, "cardSuit" : "spades"},
        {"rank" : 10, "cardSuit" : "spades"},
        {"rank" : 11, "cardSuit" : "spades"},
        {"rank" : 12, "cardSuit" : "spades"},
        {"rank" : 13, "cardSuit" : "spades"},
        {"rank" : 14, "cardSuit" : "spades"},
    ]),
};

/* Library Methods */

// shuffle - take the deck (an array) and create a new deck (an array still) with all the card randomised.
// each is card is sh=ort to be randomny above or below another card

    function shuffle(deck) { 
        return deck.sort(() => 0.5 - Math.random());
    };

    //draw : enables the player to draw cards and add them to their hand, whilst keeping track of the cards that aren't in the player's hand
    //spilt the deck object to a library and cardsTakenFromLibrary
    //For the number of cards to draw

    function draw(deck, player, numberOfCardsToDraw) {
        
        let {library, cardsTakenFromLibrary, } = deck;

        for (let index = 0; index < numberOfCardsToDraw; index++) {
            const removeTopCard = library.shift();
         
            player.hand.push(removeTopCard);
            cardsTakenFromLibrary.push(removeTopCard);
            
        };

        return [{library,  cardsTakenFromLibrary}, player];
    };

/* game, turns, phrases */
// turn : runs what player will take what turn with the turn property.
// phases : structures out the turns into an array.
// stack : a to be determined list of actions, an array, in which it is hit via run phases, 
// while execute all the action generated by the user
// rotateTurn : is able to take the turn property passed to it and then rotate teh turns, 
// so that one players doesn't take up all the turns.
// run : takes all the phrases shown and runs them.
// game : how to formula every part of those previous functions together.

    function rotateTurn(turnArray) {

        // cache the turn array first value, this will go last.
        //re map teh the trun array so,
        //if the item is index of 0 (first), then return false, thus remove it.
        //else if the item is the last index (turnArray.length - 1), then add the cache;
        //else, return the item in question.
        //then return that restructed array.

        const [toRemovePlayer, nextPlayer] = [turnArray[0], turnArray[1]];
        const restructedTurn = turnArray.map((player, index) => {
            if (index === 0) {
                return nextPlayer;
            } else if (index === turnArray.length -1) {
                return toRemovePlayer;
            } else {
                return player;
            };
        });
        return restructedTurn;
    };

    function drawFromDeck(prevDeck, setDeckTo, player, numberOfCards, setHand){
        const [newDeck, toDraw] = draw(prevDeck, player, numberOfCards,);
        setDeckTo(newDeck);
        setHand(toDraw);
    };

    function renderHand(hand, cardFace ) {
        return hand.map(({ rank, cardSuit}) => <div className={"card " + cardFace} key={rank + cardSuit}>{rank} | {cardSuit} </div>);
    };

    function rankHand(thisPlayer, hand, handValue, hasLost) {
        console.log('start', thisPlayer[hand], hand, handValue, hasLost);
        const rankOfHand = thisPlayer[hand].reduce((sumOfRank, card) => sumOfRank + card.rank,0);
        thisPlayer[handValue] = rankOfHand;
        thisPlayer[hasLost] = rankOfHand > 21 ?  true : false;
        console.log(thisPlayer);
        return thisPlayer;
    };

    //use the phase array to go through all the phrase.
    // phase are objects with functions in them.
    // also types.
    // playerAction phase will break the loop.
    // autoPhases will continue regardless.
    //It will continue up entitle the last phase has end.
    function run(phaseArray){
        phaseArray.forEach(phase => phase);
    };

    function useRunPhase(phaseArray){

    // keep track of what phrase it is.
    const [phaseIndex, setPhaseIndex] = useState(0);
    const [breakPhase, setBreakPhase] = useState(false);
        
        for (let i = 0; i < phaseArray; i++) {

            const { type, procedure, } = phaseArray[i]
            let breakCheck = false;
            if (!breakPhase) {
                if (phaseIndex > i) {
                    continue;
                } else {
                    switch (type) {
                        case 'playerAction':
                            procedure();
                            breakCheck = true;
                        break;
                        
                        case 'auto':
                            procedure();
                        break;
                    
                        default:
                            console.log('useRunPhase - error', phaseArray, phaseArray[i], type, procedure, phaseIndex, breakPhase);
                        break;
                    };
                };
            } else {
                break;
            }
                setPhaseIndex(i);
                setBreakPhase(breakCheck);
        };
    };

/* EXPORTS */
export {
    standardDeck,
    shuffle,
    draw,
    rotateTurn,
    drawFromDeck,
    renderHand,
    rankHand,
    run,
    useRunPhase,
}